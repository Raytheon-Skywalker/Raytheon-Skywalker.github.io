<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="Raytheon Skywalker"><title>算法思想之分治法(递归) 1/5 | Raytheon Skywalker</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/logo.png"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"en",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!1},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/logo.png",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!1,scale:!1},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"KEEP CALM AND CARRY ON."},scroll:{progress_bar:{enable:!1},percent:{enable:!1}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!1,style:"default"},pjax:{enable:!1},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">Raytheon Skywalker</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/categories">CATEGORIES</a></li><li class="menu-item"><a href="/tags">TAGS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/categories">CATEGORIES</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">算法思想之分治法(递归) 1/5</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">Raytheon Skywalker</span> <span class="author-label">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2019-05-16 10:20:25 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Dev-life/">Dev life</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Algorithm/">Algorithm</a>&nbsp;</li><li>| <a href="/tags/Dev-life/">Dev life</a>&nbsp;</li><li>| <a href="/tags/LeetCode/">LeetCode</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.3k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>7 Mins</span></span></div></div></div></div><div class="article-content markdown-body"><blockquote></blockquote><ol><li><h2 id="什么是分治法-Divide-and-Conquer-Algorithm-以及相关概念"><a href="#什么是分治法-Divide-and-Conquer-Algorithm-以及相关概念" class="headerlink" title="什么是分治法(Divide and Conquer Algorithm)以及相关概念"></a>什么是分治法(Divide and Conquer Algorithm)以及相关概念</h2><ol><li><blockquote><h3 id="字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。"><a href="#字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。" class="headerlink" title="字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。"></a>字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</h3></blockquote></li><li><blockquote><h3 id="分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。"><a href="#分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。" class="headerlink" title="分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。"></a>分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。</h3></blockquote></li><li><blockquote><h3 id="如果原问题可分割成k个子问题，1-lt-k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。"><a href="#如果原问题可分割成k个子问题，1-lt-k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。" class="headerlink" title="如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。"></a>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为<font color="red">使用递归</font>技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</h3></blockquote></li><li><h3 id="不断分成子问题，子问题再分（递归条件），分到能解（基础条件），然后按照某种规则合并子问题的解。即自顶向下。"><a href="#不断分成子问题，子问题再分（递归条件），分到能解（基础条件），然后按照某种规则合并子问题的解。即自顶向下。" class="headerlink" title="不断分成子问题，子问题再分（递归条件），分到能解（基础条件），然后按照某种规则合并子问题的解。即自顶向下。"></a>不断分成子问题，子问题再分（递归条件），分到能解（基础条件），然后按照某种规则合并子问题的解。即自顶向下。</h3></li><li><h3 id="什么是最优子结构-optimal-substructure"><a href="#什么是最优子结构-optimal-substructure" class="headerlink" title="什么是最优子结构[optimal substructure]"></a>什么是最优子结构[optimal substructure]</h3><ol><li><blockquote><h3 id="最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。"><a href="#最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。" class="headerlink" title="最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。"></a>最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。</h3></blockquote></li><li>感觉就是分到能解的时候，求出最优，那么整个问题就是最优的了，于是就说这个问题有最优子结构。</li><li><h3 id="什么时候没有最优子结构？？"><a href="#什么时候没有最优子结构？？" class="headerlink" title="什么时候没有最优子结构？？"></a>什么时候没有最优子结构？？</h3><blockquote><p>阶乘问题，比如旅行家问题。</p></blockquote></li></ol></li><li><h3 id="什么是重叠子问题？"><a href="#什么是重叠子问题？" class="headerlink" title="什么是重叠子问题？"></a>什么是重叠子问题？</h3><ol><li><blockquote><h3 id="用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。"><a href="#用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。" class="headerlink" title="用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。"></a>用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</h3></blockquote></li></ol></li><li><blockquote><p>当子问题相互独立时，能且只能使用分治。存在重叠子问题时，动态规划是更好的算法。 In a word, 分治法 —— 各子问题独立；动态规划 —— 各子问题重叠。</p></blockquote></li><li><blockquote><p>算法导论：算法导论： 动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠的。</p></blockquote></li><li><h3 id="什么是减治法"><a href="#什么是减治法" class="headerlink" title="什么是减治法?"></a>什么是减治法?</h3></li><li><blockquote><p>减治法是分治法的特殊情况，参见尾递归优化。<br>分治法主要是将问题分成两个子问题，然后最后将问题合并起来，从而求得其解，减治法是将问题分解，但是没有将解合并，解就在子问题的解中。通常来说，减治法的效率较高。</p></blockquote></li></ol></li><li><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol><li><h3 id="用到该思想的一些算法"><a href="#用到该思想的一些算法" class="headerlink" title="用到该思想的一些算法"></a>用到该思想的一些算法</h3><ol><li>二分搜索</li><li>大整数乘法</li><li>Strassen矩阵乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ol></li><li><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><ol><li>适用分治法的问题的特征<ol><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li><li>利用该问题分解出的子问题的解可以合并为该问题的解；</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ol></li><li><blockquote><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；<br>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；<br><font color="red">第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。<br>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</font></p></blockquote></li></ol></li><li><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>划分问题：整个问题划分成多个无关联的子问题。 （如：问题：有100枚硬币，其中1枚重量与众不同，是假币，略轻一些。如果用天平秤，请问至少称几次一定能找到这枚假币。）</li><li>递归求解：递归调用求解各个子问题。</li><li>合并问题：合并子问题的解，形成原始问题的解。</li><li><blockquote><p>伪代码：Divide-and-Conquer(P)<br>1. if |P| $\le$ n0<br>2. then return(ADHOC(P))<br>3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk<br>4. for i←1 to k<br>5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi<br>6. T ← MERGE(y1,y2,…,yk) △ 合并子问题<br>7. return(T)<br>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。<br>根据分治法的分割原则，原问题应该分为多少个子问题才较适宜？各个子问题的规模应该怎样才为适当？这些问题很难予以肯定的回答。但人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。换句话说，将一个问题分成大小相等的k个子问题的处理方法是行之有效的。许多问题可以取k=2。这种使子问题规模大致相等的做法是出自一种平衡(balancing)子问题的思想，它几乎总是比子问题规模不等的做法要好。</p></blockquote></li></ol></li><li><h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ol><li><blockquote><p>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p></blockquote><ol><li>一定是先找到最小问题规模时的求解方法；</li><li>然后考虑随着问题规模增大时的求解方法；</li><li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li></ol></li></ol></li><li><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li><blockquote><p>从分治法的一般设计模式可以看出，用它设计出的程序一般是一个递归过程。因此，分治法的计算效率通常可以用递归方程来进行分析。</p></blockquote></li><li>一般的对于a,b,d &gt; 0 其中a为子问题数,b为每个子问题中数据规模，d为子问题合并相关参数，且有：<br>$$T(n) = aT(\frac{n}{b}) + O(n^d)$$</li></ol></li></ol></li><li><h2 id="相似思想"><a href="#相似思想" class="headerlink" title="相似思想"></a>相似思想</h2><ol><li>动态规划</li><li>贪心</li><li><font color="red">递归，分治，动态规划，贪心之间的关系</font>，这边文章讲的比较清楚，建议多看看–&gt;<ol><li><a class="link" target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-tkmsqpyp-wa.html">递归、分治策略、动态规划以及贪心算法之间的关系<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/crella___/article/details/55058535">贪心和dp-本质都是对解空间遍历的剪枝<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://www.bioinfo.org.cn/~dbu/AlgorithmCourses/Lectures/LOA/LOA.pdf">算法讲义-关于问题求解方法的十八讲（卜东波，张家琳 著）<i class="fas fa-external-link-alt"></i></a><blockquote><p>大概讲就是，分治，动态规划，贪心是算法思想，递归是实现手段。分治（一般递归）的特例是动态规划，区别在于子问题是否重复，重复的用动态规划（可递归可迭代），不重复用分治。<br><br><img lazyload src="/images/loading.svg" data-src="https://pic2.zhimg.com/80/v2-0d6d1cde06a90b753193b510e5b9a5a4_hd.jpg" alt="卜东波-算法课"></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li></ol></li></ol></li><li><h3 id="维基百科·分治法"><a href="#维基百科·分治法" class="headerlink" title="维基百科·分治法"></a><a class="link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">维基百科·分治法<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="五大常用算法之一：分治算法"><a href="#五大常用算法之一：分治算法" class="headerlink" title="五大常用算法之一：分治算法"></a><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html">五大常用算法之一：分治算法<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="最优子结构（optimal-substructure）"><a href="#最优子结构（optimal-substructure）" class="headerlink" title="最优子结构（optimal substructure）"></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/article/details/52480106">最优子结构（optimal substructure）<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="分治算法（概念、特性、步骤、复杂度分析、经典例子）"><a href="#分治算法（概念、特性、步骤、复杂度分析、经典例子）" class="headerlink" title="分治算法（概念、特性、步骤、复杂度分析、经典例子）"></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/tianjing0805/article/details/75738698">分治算法（概念、特性、步骤、复杂度分析、经典例子）<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="2-2-分治策略"><a href="#2-2-分治策略" class="headerlink" title="2.2 分治策略"></a><a class="link" target="_blank" rel="noopener" href="http://kjwy.5any.com/sfsjfx/content/2/kcjj-0202.htm">2.2 分治策略<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="经典优化算法之分治法（Divide-and-Conquer-Algorithm）"><a href="#经典优化算法之分治法（Divide-and-Conquer-Algorithm）" class="headerlink" title="经典优化算法之分治法（Divide-and-Conquer Algorithm）"></a><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45986027">经典优化算法之分治法（Divide-and-Conquer Algorithm）<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="递归、分治策略、动态规划以及贪心算法之间的关系"><a href="#递归、分治策略、动态规划以及贪心算法之间的关系" class="headerlink" title="递归、分治策略、动态规划以及贪心算法之间的关系"></a><a class="link" target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-tkmsqpyp-wa.html">递归、分治策略、动态规划以及贪心算法之间的关系<i class="fas fa-external-link-alt"></i></a></h3></li><li><h3 id="贪心和dp-本质都是对解空间遍历的剪枝"><a href="#贪心和dp-本质都是对解空间遍历的剪枝" class="headerlink" title="贪心和dp-本质都是对解空间遍历的剪枝"></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/crella___/article/details/55058535">贪心和dp-本质都是对解空间遍历的剪枝<i class="fas fa-external-link-alt"></i></a></h3></li></ol></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：算法思想之分治法(递归) 1/5</li><li>Post author：Raytheon Skywalker</li><li>Create time：2019-05-16 10:20:25</li><li>Post link：https://raytheon-skywalker.tech/2019/05/16/Divide-and-conquer-method-1/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2019/05/17/General-concepts-in-algorithm-learning/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">算法学习中的必要概念</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2019/04/15/Displays-satellite-images-by-using-QGis/"><span class="title flex-center"><span class="post-nav-title-item">QGIS展示不同图商的卫片</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Raytheon Skywalker</a></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%B2%BB%E6%B3%95-Divide-and-Conquer-Algorithm-%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">什么是分治法(Divide and Conquer Algorithm)以及相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E4%B8%8A%E7%9A%84%E8%A7%A3%E9%87%8A%E6%98%AF%E2%80%9C%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E2%80%9D%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%88%90%E4%B8%A4%E4%B8%AA%E6%88%96%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%9B%B8%E5%90%8C%E6%88%96%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%9C%80%E5%90%8E%E5%AD%90%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3%EF%BC%8C%E5%8E%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%8D%B3%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%9A%84%E5%90%88%E5%B9%B6%E3%80%82"><span class="nav-number">1.1.</span> <span class="nav-text">字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E9%80%9A%E5%B8%B8%E4%BB%A5%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%E6%9D%A5%E9%AA%8C%E8%AF%81%E3%80%82%E8%80%8C%E5%AE%83%E7%9A%84%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC%E5%88%99%E5%A4%9A%E6%95%B0%E4%BB%A5%E8%A7%A3%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%9D%A5%E5%88%A4%E5%AE%9A%E3%80%82"><span class="nav-number">1.2.</span> <span class="nav-text">分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%8E%9F%E9%97%AE%E9%A2%98%E5%8F%AF%E5%88%86%E5%89%B2%E6%88%90k%E4%B8%AA%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C1-lt-k%E2%89%A4n%EF%BC%8C%E4%B8%94%E8%BF%99%E4%BA%9B%E5%AD%90%E9%97%AE%E9%A2%98%E9%83%BD%E5%8F%AF%E8%A7%A3%E5%B9%B6%E5%8F%AF%E5%88%A9%E7%94%A8%E8%BF%99%E4%BA%9B%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B1%82%E5%87%BA%E5%8E%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E7%A7%8D%E5%88%86%E6%B2%BB%E6%B3%95%E5%B0%B1%E6%98%AF%E5%8F%AF%E8%A1%8C%E7%9A%84%E3%80%82%E7%94%B1%E5%88%86%E6%B2%BB%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%E5%BE%80%E5%BE%80%E6%98%AF%E5%8E%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%BE%83%E5%B0%8F%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BF%99%E5%B0%B1%E4%B8%BA%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%8A%80%E6%9C%AF%E6%8F%90%E4%BE%9B%E4%BA%86%E6%96%B9%E4%BE%BF%E3%80%82%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%8F%8D%E5%A4%8D%E5%BA%94%E7%94%A8%E5%88%86%E6%B2%BB%E6%89%8B%E6%AE%B5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8E%9F%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%87%B4%E8%80%8C%E5%85%B6%E8%A7%84%E6%A8%A1%E5%8D%B4%E4%B8%8D%E6%96%AD%E7%BC%A9%E5%B0%8F%EF%BC%8C%E6%9C%80%E7%BB%88%E4%BD%BF%E5%AD%90%E9%97%AE%E9%A2%98%E7%BC%A9%E5%B0%8F%E5%88%B0%E5%BE%88%E5%AE%B9%E6%98%93%E7%9B%B4%E6%8E%A5%E6%B1%82%E5%87%BA%E5%85%B6%E8%A7%A3%E3%80%82%E8%BF%99%E8%87%AA%E7%84%B6%E5%AF%BC%E8%87%B4%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BA%A7%E7%94%9F%E3%80%82%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92%E5%83%8F%E4%B8%80%E5%AF%B9%E5%AD%AA%E7%94%9F%E5%85%84%E5%BC%9F%EF%BC%8C%E7%BB%8F%E5%B8%B8%E5%90%8C%E6%97%B6%E5%BA%94%E7%94%A8%E5%9C%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%EF%BC%8C%E5%B9%B6%E7%94%B1%E6%AD%A4%E4%BA%A7%E7%94%9F%E8%AE%B8%E5%A4%9A%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E3%80%82"><span class="nav-number">1.3.</span> <span class="nav-text">如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%96%AD%E5%88%86%E6%88%90%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AD%90%E9%97%AE%E9%A2%98%E5%86%8D%E5%88%86%EF%BC%88%E9%80%92%E5%BD%92%E6%9D%A1%E4%BB%B6%EF%BC%89%EF%BC%8C%E5%88%86%E5%88%B0%E8%83%BD%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%E6%9D%A1%E4%BB%B6%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89%E7%85%A7%E6%9F%90%E7%A7%8D%E8%A7%84%E5%88%99%E5%90%88%E5%B9%B6%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E3%80%82%E5%8D%B3%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E3%80%82"><span class="nav-number">1.4.</span> <span class="nav-text">不断分成子问题，子问题再分（递归条件），分到能解（基础条件），然后按照某种规则合并子问题的解。即自顶向下。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84-optimal-substructure"><span class="nav-number">1.5.</span> <span class="nav-text">什么是最优子结构[optimal substructure]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%98%AF%E4%BE%9D%E8%B5%96%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98%E5%92%8C%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E8%80%8C%E6%88%90%E7%AB%8B%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%82%E5%90%84%E5%AD%90%E9%97%AE%E9%A2%98%E5%85%B7%E6%9C%89%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%8C%E5%B0%B1%E8%83%BD%E6%B1%82%E5%87%BA%E6%95%B4%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%9D%A1%E4%BB%B6%E6%88%90%E7%AB%8B%E3%80%82"><span class="nav-number">1.6.</span> <span class="nav-text">最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B2%A1%E6%9C%89%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%EF%BC%9F%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">什么时候没有最优子结构？？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">什么是重叠子问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%9D%A5%E6%B1%82%E8%A7%A3%E5%8E%9F%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%8F%8D%E5%A4%8D%E5%9C%B0%E8%A7%A3%E5%90%8C%E6%A0%B7%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%80%BB%E6%98%AF%E5%9C%A8%E4%BA%A7%E7%94%9F%E6%96%B0%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%82%E5%AF%B9%E4%B8%A4%E4%B8%AA%E5%AD%90%E9%97%AE%E9%A2%98%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E4%BB%AC%E7%A1%AE%E5%AE%9E%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%BD%9C%E4%B8%BA%E4%B8%8D%E5%90%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%88%99%E5%AE%83%E4%BB%AC%E6%98%AF%E9%87%8D%E5%8F%A0%E7%9A%84%E3%80%82"><span class="nav-number">1.9.</span> <span class="nav-text">用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%8F%E6%B2%BB%E6%B3%95"><span class="nav-number">1.10.</span> <span class="nav-text">什么是减治法?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">怎么用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%88%B0%E8%AF%A5%E6%80%9D%E6%83%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">用到该思想的一些算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">2.2.</span> <span class="nav-text">适用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.3.</span> <span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">思考过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E4%BC%BC%E6%80%9D%E6%83%B3"><span class="nav-number">3.</span> <span class="nav-text">相似思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%C2%B7%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">维基百科·分治法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">五大常用算法之一：分治算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%EF%BC%88optimal-substructure%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">最优子结构（optimal substructure）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%EF%BC%88%E6%A6%82%E5%BF%B5%E3%80%81%E7%89%B9%E6%80%A7%E3%80%81%E6%AD%A5%E9%AA%A4%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">分治算法（概念、特性、步骤、复杂度分析、经典例子）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="nav-number">4.5.</span> <span class="nav-text">2.2 分治策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%88Divide-and-Conquer-Algorithm%EF%BC%89"><span class="nav-number">4.6.</span> <span class="nav-text">经典优化算法之分治法（Divide-and-Conquer Algorithm）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E3%80%81%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BB%A5%E5%8F%8A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.7.</span> <span class="nav-text">递归、分治策略、动态规划以及贪心算法之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E5%92%8Cdp-%E6%9C%AC%E8%B4%A8%E9%83%BD%E6%98%AF%E5%AF%B9%E8%A7%A3%E7%A9%BA%E9%97%B4%E9%81%8D%E5%8E%86%E7%9A%84%E5%89%AA%E6%9E%9D"><span class="nav-number">4.8.</span> <span class="nav-text">贪心和dp-本质都是对解空间遍历的剪枝</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/lazyload.js"></script><div class="post-scripts"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script></div></body></html>